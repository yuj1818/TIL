# HTTP/1.1 과 HTTP/2.0의 차이

## HTTP/1.1

- 클라이언트는 메소드를 호출하여 서버에 텍스트 기반 요청을 보냄
- 응답으로 서버는 HTML 페이지와 같은 리소스를 클라이언트에 다시 보냄
- 하나의 커넥션을 이용하여 하나의 요청을 처리할 수 있어 멀티미디어 리소스가 많은 상황에서는 네트워크 지연이 발생

### HTTP/1.1의 문제점

**HOL(Head Of Line) Blocking**

- 앞선 요청에 의해 후에 발생한 요청이 지연되는 현상
- 파이프라인 방식을 이용하기 때문에 순차적으로 응답이 되어 지연이 발생

**무거운 헤더**

- HTTP 요청들은 header 정보가 대부분 동일하지만 HTTP/1.1에서 헤더를 지속적으로 중복 사용함
- 쿠키 정보 또한 매 요청마다 헤더에 포함하여 전송
- 불필요한 정보를 주고 받음으로써 리소스의 낭비가 발생

### RTT(Round Trip Time) 증가

- 요청마다 커넥션을 만들고 3-way handshake가 반복적으로 일어나며, 불필요한 RTT 증가와 네트워크 지연을 초래

### HTTP/1.1 성능 개선 시도

**Image Spriting**

- 여러 이미지를 모아 큰 이미지를 만들어 CSS로 해당 이미지의 좌표값을 지정하여 사용

**Domain Sharding**

- 하나의 도메인에 대해 여러 개의 커넥션을 생성하여 병렬로 요청 보냄

**CSS, JavaScript 최소화**

- 전송 데이터 용량을 줄이기 위해 CSS, JavaScript 파일을 최소화하여 통신

## HTTP/2.0

- 압축, 다중화 및 우선 순위 지정과 같은 기술을 사용하여 웹 페이지 로드 대기 시간을 줄임

### Multiplexed Streams

- 하나의 커넥션을 이용하여 여러 메시지를 주고 받을 수 있도록 함
- 요청 순서와 상관없이 스트림으로 받아 HOL Blocking 문제 해결

### Stream Prioritization

- 응답에 대한 우선 순위를 정하여 진행
- 렌더링에 대한 요청을 우선으로 하는 등

### Servver Push

- 기존에는 HTML 문서 요청 후, 각 리소스들을 다시 요청했다면 클라이언트의 요청을 최소화하고 서버가 알아서 리소스를 보내주도록 개선

### Header Compression

- 헤더에 중복된 정보가 많아 리소스 낭비가 심했던 단점을 개선하기 위해 Header Table과 Huffman Encoding을 사용하는 HPACK 압축 방식으로 이를 개선
- 클라이언트와 서버는 각각 Header Table을 관리하며 이전 요청과 중복되는 필드는 table의 index만 보내고 변경되는 값은 Huffman Encoding하여 보냄으로써 Header의 크기를 경량화