# 알고리즘

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
- 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
- 컴퓨터 분야에서 알고리즘을 표현하는 방법
    - 의사코드(Pseudocode)

    <img src="https://github.com/yuj1818/TIL/assets/95585314/3bfb777a-09b3-4756-b410-cc258a5b8184" />
    
    - 순서도
    
    <img src="https://github.com/yuj1818/TIL/assets/95585314/b1825854-3ac3-4b6a-8087-7c26b5dcfa0c" />
    

## 알고리즘의 성능

### 무엇이 좋은 알고리즘인가?

- 정확성
    - 얼마나 정확하게 동작하는가
- 작업량
    - 얼마나 적은 연산으로 원하는 결과를 얻어내는가
- 메모리 사용량
    - 얼마나 적은 메모리를 사용하는가
- 단순성
    - 얼마나 단순한가
- 최적성
    - 더 이상 개선할 여지없이 최적화되었는가

### 시간 복잡도(Time complexity)

- 알고리즘의 작업량을 표현할 때 시간 복잡도로 표현
- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산
- 시간 복잡도 ≒ 빅-오(O) 표기법
    - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
    - 계수(Coefficient)는 생략하여 표시
- 요소 수가 증가함에 따라 각기 다른 시간 복잡도의 알고리즘은 아래와 같은 연산 수를 보임
    
    <img src="https://github.com/yuj1818/TIL/assets/95585314/a51928c3-2d4f-4a02-91a2-287b2a0e54f9" />

## 알고리즘 설계 기법의 종류

1. 전체를 다 보기(Brute Force - 완전 탐색)
    - 배열 - 반복문을 다 돌리기
    - 그래프 - DFS, BFS
2. 상황마다 좋은 걸 고르기(Greedy - 탐욕)
    - 규칙을 찾는 것
    - 주의사항 - 항상 좋은 것을 뽑아도, 최종 결과가 제일 좋다는 것은 보장되지 않음
3. 하나의 큰 문제를 작은 문제로 나누어 부분적으로 해결하는 것(Dynamic Programming)
    - Memoization 기법 활용
    - 점화식(bottom-up), 재귀(top-down)
4. 큰 문제를 작은 문제로 쪼개서 해결하는 것(Divide and Conquer - 분할 정복)
5. 전체 중 가능성 없는 것을 빼고 보는 것(Backtracking - 백트래킹)
    - 가지치기

## 알고리즘 종류

### | [배열](./array.md)

### | [정렬](./sort.md)

### | [완전 검색](./exaustive_search.md)

### | [그리디](./greedy.md)

### | [부분 집합](./subset.md)

### | [검색](./search.md)

### | [문자열](./string.md)

### | [스택](./stack.md)

### | [큐](./queue.md)

### | [트리](./tree.md)

### | [완전 탐색](./brute_force.md)

### | [분할 정복](./divide_and_conquer.md)