# 부분 집합

- 집합에 포함된 원소들을 선택하는 것
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것
- N 개의 원소를 포함한 집합
    - 자기 자신과 공집합 포함한 모든 부분 집합의 개수는 2**n개
    - 원소의 수가 증가하면 부분 집합의 개수는 지수적으로 증가

## 부분집합의 수

- 집합의 원소가 n개일 때, 공집합을 포함한 부분 집합의 수는 2^n개 이다.
- 이는 각 원소를 부분 집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.

## 비트 연산자

### 비트 연산자

'&' - 비트 단위로 AND 연산

'|' - 비트 단위로 OR 연산

'<<' - 피연산자의 비트 열을 왼쪽으로 이동

'>>' - 피연산자의 비트 열을 오른쪽으로 이동

### << 연산자

- 1 << 2
    - 2^n. 즉, 원소가 n개일 경우의 모든 부분 집합의 수를 의미

### & 연산자

- i & (1 << j)
    - i의 j번째 비트가 1인지 아닌지를 검사

## 부분집합 합(Subset Sum) 문제

- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지 알아내는 문제
- 예를 들어, [-7, -3, -2, 5, 8]라는 집합이 있을 때, [-3, -2, 5]는 이 집합의 부분집합이면서 (-3)+(-2)+5 = 0이므로 이 경우의 답은 참
- 완전 검색 기법으로 부분 집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분 집합을 생성한 후에 각 부분 집합의 합을 계산해야 한다.

```python
arr = [3, 6, 7, 1, 5, 4]

n = len(arr)

for i in range(1 << n):     # 1 << n: 부분 집합의 개수
    for j in range(n):
        if i & (1 << j):    # i의 j번 비트가 1인 경우
            print(arr[j], end=", ")
    print()
print()
```

## 단순하게 모든 부분 집합 생성하는 방법

- 4개 원소를 포함한 집합에 대한 power set 구하기

```python
for i1 in [0, 1]:
		bit[0] = i1
				for i2 in [0, 1]:
						bit[1] = i2
						for i3 in [0, 1]:
								bit[2] = i3
								for i4 in [0, 1]:
										bit[3] = i4
										print(array)
```

## 부분 집합 생성 방법

- 바이너리 카운팅을 통한 사전적 순서
    - 부분집합을 생성하기 위한 가장 자연스러운 방법
    - 바이너리 카운팅은 사전적 순서로 생성하기 위한 가장 간단한 방법
    - 바이너리 카운팅
        - 원소 수에 해당하는 N개의 비트열을 이용
        - n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미
    
    ```python
    #subset1
    
    # arr = [3,6,7,1,5,4]
    arr = [1,2,3,4]
    n = len(arr)
    # for i in range((1<<n) - 1):
    for i in range(1, (1<<n) // 2):
        subset1 = []
        subset2 = []
        for j in range(n):
            if i & (i << j): #j번 비트가 0이 아니면
                # print(i,j)
                subset1.append((arr[j]))
            # print(*subtree1)
            else:
                subset2.append(arr[j])
        print(subset1, subset2)
    ```